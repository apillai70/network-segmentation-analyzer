"""
App-Specific Threat Surface Analysis Document Generator
=========================================================
Generates PERSONALIZED security documents for each application owner
focusing on THEIR specific issues and action items.

Key Principle: App owners should see THEIR problems, not generic advice.

Author: Network Security Team
Version: 2.0 (App-Specific)
"""

import logging
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional
from docx import Document
from docx.shared import Inches, Pt, RGBColor
from docx.enum.text import WD_ALIGN_PARAGRAPH
from collections import defaultdict

logger = logging.getLogger(__name__)


class AppSpecificThreatSurfaceDocument:
    """Generates app-specific threat surface analysis documents"""

    def __init__(self, app_name: str, app_data: Optional[Dict] = None):
        """Initialize document generator

        Args:
            app_name: Application name
            app_data: Application topology and analysis data
        """
        self.app_name = app_name
        self.app_data = app_data or {}
        self.doc = Document()
        self._setup_styles()

        # Extract app-specific data
        self.dependencies = self.app_data.get('predicted_dependencies', [])
        self.zone = self.app_data.get('security_zone', 'UNKNOWN')
        self.dns_validation = self.app_data.get('dns_validation', {})
        self.validation_metadata = self.app_data.get('validation_metadata', {})

    def _setup_styles(self):
        """Setup custom styles"""
        styles = self.doc.styles

        try:
            # Heading styles
            h1_style = styles['Heading 1']
            h1_style.font.size = Pt(18)
            h1_style.font.color.rgb = RGBColor(0, 51, 102)  # Professional blue
            h1_style.font.bold = True

            h2_style = styles['Heading 2']
            h2_style.font.size = Pt(14)
            h2_style.font.color.rgb = RGBColor(0, 102, 204)

            h3_style = styles['Heading 3']
            h3_style.font.size = Pt(12)
            h3_style.font.color.rgb = RGBColor(51, 102, 153)
        except:
            pass

    def generate_document(self, output_path: str):
        """Generate app-specific threat surface document

        Args:
            output_path: Output path for Word document
        """
        logger.info(f"Generating app-specific threat surface document for: {self.app_name}")

        # Cover page
        self._add_cover_page()
        self.doc.add_page_break()

        # Executive summary with SPECIFIC findings
        self._add_executive_summary()
        self.doc.add_page_break()

        # Application architecture - THEIR app
        self._add_application_architecture()
        self.doc.add_page_break()

        # Security findings - THEIR issues
        self._add_security_findings()
        self.doc.add_page_break()

        # Action plan - THEIR tasks
        self._add_action_plan()
        self.doc.add_page_break()

        # Firewall rules - THEIR rules
        self._add_firewall_rules()

        # Save document
        output_file = Path(output_path)
        output_file.parent.mkdir(parents=True, exist_ok=True)

        self.doc.save(str(output_file))
        logger.info(f"✓ App-specific threat surface document saved: {output_path}")

    def _add_cover_page(self):
        """Add professional cover page"""
        # Title
        title = self.doc.add_heading(
            f'Threat Surface Analysis\n{self.app_name}',
            level=0
        )
        title.alignment = WD_ALIGN_PARAGRAPH.CENTER

        # Spacing
        for _ in range(5):
            self.doc.add_paragraph()

        # Document info
        info_para = self.doc.add_paragraph()
        info_para.alignment = WD_ALIGN_PARAGRAPH.CENTER
        info_para.add_run(f'Application: {self.app_name}\n').bold = True
        info_para.add_run(f'Security Zone: {self.zone}\n')
        info_para.add_run(f'Generated: {datetime.now().strftime("%B %d, %Y")}\n')
        info_para.add_run('Classification: Confidential\n')

        for _ in range(3):
            self.doc.add_paragraph()

        # Footer
        footer = self.doc.add_paragraph()
        footer.alignment = WD_ALIGN_PARAGRAPH.CENTER
        footer.add_run('Prepared by: Network Security Team\n')
        footer.add_run('Auto-generated by Network Segmentation Analyzer v3.0\n')

    def _add_executive_summary(self):
        """Add executive summary with APP-SPECIFIC findings"""
        self.doc.add_heading('Executive Summary', level=1)

        # App-specific intro
        intro = self.doc.add_paragraph()
        intro.add_run(f"This document analyzes the security posture of {self.app_name} ")
        intro.add_run("and provides actionable recommendations specific to your application. ")
        intro.add_run("Focus on the issues and action items highlighted in this document - ")
        intro.add_run("they are tailored to your application's actual network traffic and configuration.")

        self.doc.add_paragraph()

        # Quick stats - APP SPECIFIC
        self.doc.add_heading('Your Application at a Glance', level=2)

        stats_table = self.doc.add_table(rows=5, cols=2)
        stats_table.style = 'Medium Shading 1 Accent 1'

        # Count issues
        dns_issues = (self.dns_validation.get('mismatch', 0) +
                     self.dns_validation.get('nxdomain', 0) +
                     self.dns_validation.get('failed', 0))

        external_deps = [d for d in self.dependencies if d.get('type') == 'downstream_app']
        internal_deps = [d for d in self.dependencies if d.get('type') in ['database', 'cache', 'queue']]

        stats = [
            ('Security Zone', self.zone),
            ('Total Dependencies', str(len(self.dependencies))),
            ('External Services', str(len(external_deps))),
            ('Internal Services', str(len(internal_deps))),
            ('DNS Issues Found', str(dns_issues))
        ]

        for idx, (metric, value) in enumerate(stats):
            stats_table.rows[idx].cells[0].text = metric
            stats_table.rows[idx].cells[0].paragraphs[0].runs[0].bold = True
            stats_table.rows[idx].cells[1].text = value

        self.doc.add_paragraph()

        # Key findings - APP SPECIFIC
        self.doc.add_heading('Key Findings for Your Application', level=2)

        findings = []

        # Zone-specific finding
        if self.zone == 'WEB_TIER':
            findings.append("✓ Internet-facing application - requires WAF and DDoS protection")
        elif self.zone == 'APP_TIER':
            findings.append("✓ Application tier - focus on service-to-service authentication")
        elif self.zone == 'DATA_TIER':
            findings.append("✓ Data tier - requires strict access controls and monitoring")
        else:
            findings.append(f"⚠ Classified as {self.zone} - needs zone validation")

        # Dependency findings
        if len(self.dependencies) == 0:
            findings.append("⚠ No dependencies detected - may need additional flow data")
        elif len(self.dependencies) > 15:
            findings.append(f"⚠ {len(self.dependencies)} dependencies detected - complex attack surface")
        else:
            findings.append(f"✓ {len(self.dependencies)} dependencies - manageable complexity")

        # DNS findings
        if dns_issues == 0:
            findings.append("✓ No DNS configuration issues detected")
        elif dns_issues <= 3:
            findings.append(f"⚠ {dns_issues} DNS configuration issues - review recommended")
        else:
            findings.append(f"⚠ {dns_issues} DNS configuration issues - immediate attention required")

        # External dependencies
        if len(external_deps) > 0:
            findings.append(f"⚠ {len(external_deps)} external service dependencies - validate security")

        for finding in findings:
            self.doc.add_paragraph(finding, style='List Bullet')

        self.doc.add_paragraph()

        # Priority actions - APP SPECIFIC
        self.doc.add_heading('Top 3 Priority Actions for Your Team', level=2)

        priority_actions = self._get_priority_actions()

        for idx, action in enumerate(priority_actions[:3], 1):
            para = self.doc.add_paragraph(style='List Bullet')
            para.add_run(f'{idx}. ').bold = True
            para.add_run(action)

    def _add_application_architecture(self):
        """Add APPLICATION-SPECIFIC architecture section"""
        self.doc.add_heading('Your Application Architecture', level=1)

        arch_intro = f"{self.app_name} operates in the {self.zone} security zone and communicates with the following services based on observed network traffic:"
        self.doc.add_paragraph(arch_intro)

        self.doc.add_paragraph()

        # Dependency breakdown - SPECIFIC TO THIS APP
        self.doc.add_heading('Service Dependencies', level=2)

        if not self.dependencies:
            no_deps = self.doc.add_paragraph()
            no_deps.add_run("⚠ No dependencies detected. ").bold = True
            no_deps.add_run("This could indicate:\n")
            self.doc.add_paragraph("• Insufficient flow data collection period", style='List Bullet')
            self.doc.add_paragraph("• Application is standalone with no external dependencies", style='List Bullet')
            self.doc.add_paragraph("• Flow data not capturing all communication paths", style='List Bullet')

            self.doc.add_paragraph()
            rec = self.doc.add_paragraph()
            rec.add_run("Recommendation: ").bold = True
            rec.add_run("Work with your application team to validate whether these dependencies are expected.")
        else:
            # Group dependencies by type
            dep_by_type = defaultdict(list)
            for dep in self.dependencies:
                dep_type = dep.get('type', 'unknown')
                dep_by_type[dep_type].append(dep)

            # Show each type with details
            for dep_type, deps in sorted(dep_by_type.items()):
                self.doc.add_heading(f'{dep_type.replace("_", " ").title()} ({len(deps)})', level=3)

                if len(deps) <= 10:
                    # Show all if reasonable number
                    for dep in deps:
                        dep_name = dep.get('name', 'Unknown')
                        self.doc.add_paragraph(f"• {dep_name}", style='List Bullet')
                else:
                    # Show first 10 and summarize rest
                    for dep in deps[:10]:
                        dep_name = dep.get('name', 'Unknown')
                        self.doc.add_paragraph(f"• {dep_name}", style='List Bullet')

                    remaining = len(deps) - 10
                    self.doc.add_paragraph(f"• ... and {remaining} more", style='List Bullet')

                self.doc.add_paragraph()

        # Communication patterns - SPECIFIC
        self.doc.add_heading('Communication Patterns', level=2)

        patterns_intro = f"Based on network flow analysis, {self.app_name} exhibits the following communication patterns:"
        self.doc.add_paragraph(patterns_intro)

        patterns = []

        if self.zone == 'WEB_TIER':
            patterns.append("Accepts inbound connections from the internet (HTTP/HTTPS)")
            patterns.append("Communicates with application tier services")
        elif self.zone == 'APP_TIER':
            patterns.append("Receives requests from web tier")
            patterns.append("Communicates with data tier and cache services")

        if len([d for d in self.dependencies if d.get('type') == 'database']) > 0:
            db_count = len([d for d in self.dependencies if d.get('type') == 'database'])
            patterns.append(f"Connects to {db_count} database(s)")

        if len([d for d in self.dependencies if d.get('type') == 'cache']) > 0:
            cache_count = len([d for d in self.dependencies if d.get('type') == 'cache'])
            patterns.append(f"Uses {cache_count} cache service(s) for performance")

        if len([d for d in self.dependencies if d.get('type') == 'downstream_app']) > 0:
            api_count = len([d for d in self.dependencies if d.get('type') == 'downstream_app'])
            patterns.append(f"Integrates with {api_count} external service(s)")

        if not patterns:
            patterns.append(f"Standard {self.zone} communication patterns")

        for pattern in patterns:
            self.doc.add_paragraph(pattern, style='List Bullet')

    def _add_security_findings(self):
        """Add SPECIFIC security findings for THIS app"""
        self.doc.add_heading('Security Findings for Your Application', level=1)

        findings_intro = "This section highlights specific security issues identified for your application based on network traffic analysis and DNS validation."
        self.doc.add_paragraph(findings_intro)

        self.doc.add_paragraph()

        # DNS Security - APP SPECIFIC
        self._add_dns_findings()

        # Exposure analysis - APP SPECIFIC
        self._add_exposure_findings()

        # Dependency security - APP SPECIFIC
        self._add_dependency_findings()

    def _add_dns_findings(self):
        """Add DNS findings specific to this app"""
        self.doc.add_heading('DNS Configuration Issues', level=2)

        total_issues = (self.dns_validation.get('mismatch', 0) +
                       self.dns_validation.get('nxdomain', 0) +
                       self.dns_validation.get('failed', 0))

        if total_issues == 0:
            good_news = self.doc.add_paragraph()
            run = good_news.add_run("✓ Good news! ")
            run.bold = True
            run.font.color.rgb = RGBColor(0, 128, 0)
            good_news.add_run("No DNS configuration issues detected for your application.")
            self.doc.add_paragraph()
            return

        # Show actual issues for THIS app
        issues_para = self.doc.add_paragraph()
        run = issues_para.add_run(f"⚠ {total_issues} DNS configuration issue(s) detected for {self.app_name}:")
        run.bold = True
        run.font.color.rgb = RGBColor(255, 140, 0)

        self.doc.add_paragraph()

        # DNS Mismatches - THEIR specific mismatches
        if self.dns_validation.get('mismatch', 0) > 0:
            self.doc.add_heading(f"{self.dns_validation.get('mismatch', 0)} DNS Mismatch(es)", level=3)

            mismatch_text = "The following IPs have DNS records that don't match forward and reverse lookups:"
            self.doc.add_paragraph(mismatch_text)

            # Extract actual mismatches
            mismatches = []
            for ip, metadata in self.validation_metadata.items():
                if metadata.get('status') == 'mismatch':
                    mismatches.append({
                        'ip': ip,
                        'reverse': metadata.get('reverse_hostname', 'N/A'),
                        'forward_ip': metadata.get('forward_ip', 'N/A')
                    })

            if mismatches:
                mismatch_table = self.doc.add_table(rows=len(mismatches[:10])+1, cols=3)
                mismatch_table.style = 'Light Grid Accent 1'

                # Header
                mismatch_table.rows[0].cells[0].text = 'IP Address'
                mismatch_table.rows[0].cells[1].text = 'Reverse DNS'
                mismatch_table.rows[0].cells[2].text = 'Forward Lookup IP'
                for cell in mismatch_table.rows[0].cells:
                    cell.paragraphs[0].runs[0].bold = True

                # Data
                for idx, mm in enumerate(mismatches[:10], 1):
                    mismatch_table.rows[idx].cells[0].text = mm['ip']
                    mismatch_table.rows[idx].cells[1].text = mm['reverse']
                    mismatch_table.rows[idx].cells[2].text = mm['forward_ip']

                self.doc.add_paragraph()

                action = self.doc.add_paragraph()
                action.add_run("Action Required: ").bold = True
                action.add_run("Coordinate with your network team to correct these DNS records.")

            self.doc.add_paragraph()

        # NXDOMAIN issues - THEIR specific IPs
        if self.dns_validation.get('nxdomain', 0) > 0:
            self.doc.add_heading(f"{self.dns_validation.get('nxdomain', 0)} Missing DNS Record(s)", level=3)

            nxd_text = "These IPs don't have reverse DNS records configured:"
            self.doc.add_paragraph(nxd_text)

            # Extract NXDOMAIN IPs
            nxdomain_ips = []
            for ip, metadata in self.validation_metadata.items():
                if metadata.get('status') == 'nxdomain':
                    nxdomain_ips.append(ip)

            for ip in nxdomain_ips[:10]:
                self.doc.add_paragraph(f"• {ip}", style='List Bullet')

            self.doc.add_paragraph()

            action = self.doc.add_paragraph()
            action.add_run("Action Required: ").bold = True
            action.add_run("Add PTR records for these IPs to improve network visibility and troubleshooting.")

    def _add_exposure_findings(self):
        """Add exposure findings specific to this app"""
        self.doc.add_heading('Network Exposure', level=2)

        if self.zone == 'WEB_TIER':
            exposure = self.doc.add_paragraph()
            run = exposure.add_run("⚠ Your application is Internet-facing (Web Tier). ")
            run.bold = True
            run.font.color.rgb = RGBColor(255, 140, 0)

            self.doc.add_paragraph()
            self.doc.add_paragraph("Your application MUST have these security controls:", style='List Bullet')
            self.doc.add_paragraph("• Web Application Firewall (WAF)", style='List Bullet')
            self.doc.add_paragraph("• DDoS protection and rate limiting", style='List Bullet')
            self.doc.add_paragraph("• TLS/SSL encryption for all connections", style='List Bullet')
            self.doc.add_paragraph("• Input validation and output encoding", style='List Bullet')
            self.doc.add_paragraph("• Regular security scanning and penetration testing", style='List Bullet')
        elif self.zone == 'DATA_TIER':
            exposure = self.doc.add_paragraph()
            run = exposure.add_run("✓ Your application is in the Data Tier (not internet-facing). ")
            run.bold = True
            run.font.color.rgb = RGBColor(0, 128, 0)

            self.doc.add_paragraph()
            self.doc.add_paragraph("Ensure the following controls are in place:", style='List Bullet')
            self.doc.add_paragraph("• Only accessible from application tier", style='List Bullet')
            self.doc.add_paragraph("• Database activity monitoring enabled", style='List Bullet')
            self.doc.add_paragraph("• Encrypted connections (TLS)", style='List Bullet')
            self.doc.add_paragraph("• Regular backup and recovery testing", style='List Bullet')
        else:
            exposure = self.doc.add_paragraph()
            exposure.add_run(f"Your application is in the {self.zone}. ").bold = True

            self.doc.add_paragraph()
            self.doc.add_paragraph("Standard security controls required:", style='List Bullet')
            self.doc.add_paragraph("• Network segmentation between tiers", style='List Bullet')
            self.doc.add_paragraph("• TLS encryption for service communications", style='List Bullet')
            self.doc.add_paragraph("• Least privilege access controls", style='List Bullet')

        self.doc.add_paragraph()

    def _add_dependency_findings(self):
        """Add dependency security findings"""
        self.doc.add_heading('Dependency Security Review', level=2)

        if not self.dependencies:
            self.doc.add_paragraph("No dependencies to review.")
            return

        # External dependencies concern
        external_deps = [d for d in self.dependencies if d.get('type') == 'downstream_app']

        if external_deps:
            ext_para = self.doc.add_paragraph()
            ext_para.add_run(f"⚠ {len(external_deps)} External Service Dependencies:").bold = True

            self.doc.add_paragraph()

            for dep in external_deps[:10]:
                dep_name = dep.get('name', 'Unknown')
                self.doc.add_paragraph(f"• {dep_name}", style='List Bullet')

            self.doc.add_paragraph()

            recommendation = self.doc.add_paragraph()
            recommendation.add_run("Recommendation: ").bold = True
            recommendation.add_run("Verify that all external service communications:")
            self.doc.add_paragraph("1. Use encrypted connections (HTTPS/TLS)", style='List Bullet')
            self.doc.add_paragraph("2. Implement proper authentication and authorization", style='List Bullet')
            self.doc.add_paragraph("3. Have monitoring and alerting configured", style='List Bullet')
            self.doc.add_paragraph("4. Are documented and approved by security team", style='List Bullet')

            self.doc.add_paragraph()

    def _add_action_plan(self):
        """Add SPECIFIC action plan for THIS app"""
        self.doc.add_heading('Action Plan for Your Team', level=1)

        action_intro = f"This action plan is specific to {self.app_name}. Work with your network and security teams to implement these recommendations."
        self.doc.add_paragraph(action_intro)

        self.doc.add_paragraph()

        # Get priority actions
        priority_actions = self._get_priority_actions()

        # Immediate actions
        self.doc.add_heading('Immediate Actions (This Week)', level=2)

        immediate_count = 0
        for action in priority_actions:
            if immediate_count >= 3:
                break
            para = self.doc.add_paragraph(style='List Bullet')
            para.add_run('⚠ ').font.color.rgb = RGBColor(255, 0, 0)
            para.add_run(action)
            immediate_count += 1

        # Short-term actions
        self.doc.add_paragraph()
        self.doc.add_heading('Short-Term Actions (Next 30 Days)', level=2)

        short_term = self._get_short_term_actions()
        for action in short_term[:5]:
            para = self.doc.add_paragraph(style='List Bullet')
            para.add_run('◆ ')
            para.add_run(action)

        # Long-term actions
        self.doc.add_paragraph()
        self.doc.add_heading('Long-Term Improvements (Next 90 Days)', level=2)

        long_term = self._get_long_term_actions()
        for action in long_term[:5]:
            para = self.doc.add_paragraph(style='List Bullet')
            para.add_run('○ ')
            para.add_run(action)

    def _add_firewall_rules(self):
        """Add SPECIFIC firewall rules for THIS app"""
        self.doc.add_heading('Required Firewall Rules', level=1)

        rules_intro = f"The following firewall rules are required for {self.app_name} based on observed network traffic. Work with your network team to implement these rules."
        self.doc.add_paragraph(rules_intro)

        self.doc.add_paragraph()

        if not self.dependencies:
            no_rules = self.doc.add_paragraph()
            no_rules.add_run("Note: ").bold = True
            no_rules.add_run("No dependencies detected, so specific rules cannot be generated. Ensure default deny-all policies are in place.")
            return

        # Generate specific rules based on dependencies
        rules = []

        # Inbound rules
        if self.zone == 'WEB_TIER':
            rules.append({
                'direction': 'INBOUND',
                'source': 'Internet',
                'destination': f'{self.app_name} (Web Tier)',
                'port': 'TCP/443',
                'purpose': 'HTTPS traffic from users'
            })
            rules.append({
                'direction': 'INBOUND',
                'source': 'Internet',
                'destination': f'{self.app_name} (Web Tier)',
                'port': 'TCP/80',
                'purpose': 'HTTP redirect to HTTPS'
            })

        # Outbound rules based on dependencies
        for dep in self.dependencies[:15]:  # Top 15 dependencies
            dep_type = dep.get('type', 'service')
            dep_name = dep.get('name', 'Unknown')
            port = self._guess_port(dep_type)

            rules.append({
                'direction': 'OUTBOUND',
                'source': f'{self.app_name}',
                'destination': dep_name,
                'port': port,
                'purpose': f'Communication with {dep_type}'
            })

        # Create rules table
        if rules:
            rules_table = self.doc.add_table(rows=len(rules)+1, cols=5)
            rules_table.style = 'Light Grid Accent 1'

            # Header
            headers = ['Direction', 'Source', 'Destination', 'Port/Protocol', 'Purpose']
            for idx, header in enumerate(headers):
                rules_table.rows[0].cells[idx].text = header
                rules_table.rows[0].cells[idx].paragraphs[0].runs[0].bold = True

            # Rules
            for idx, rule in enumerate(rules, 1):
                rules_table.rows[idx].cells[0].text = rule['direction']
                rules_table.rows[idx].cells[1].text = rule['source']
                rules_table.rows[idx].cells[2].text = rule['destination']
                rules_table.rows[idx].cells[3].text = rule['port']
                rules_table.rows[idx].cells[4].text = rule['purpose']

        self.doc.add_paragraph()

        important = self.doc.add_paragraph()
        important.add_run("Important: ").bold = True
        important.add_run("These rules should be implemented with a default-deny policy. All traffic not explicitly allowed should be blocked and logged.")

    # Helper methods
    def _get_priority_actions(self) -> List[str]:
        """Get priority actions specific to this app"""
        actions = []

        # DNS issues
        dns_issues = (self.dns_validation.get('mismatch', 0) +
                     self.dns_validation.get('nxdomain', 0))

        if dns_issues > 5:
            actions.append(f"Fix {dns_issues} DNS configuration issues for improved network reliability")
        elif dns_issues > 0:
            actions.append(f"Review and fix {dns_issues} DNS configuration issue(s)")

        # Zone-specific
        if self.zone == 'WEB_TIER':
            actions.append("Verify WAF is deployed and properly configured for internet-facing application")
        elif self.zone == 'DATA_TIER':
            actions.append("Enable database activity monitoring and audit logging")
        elif self.zone == 'UNKNOWN':
            actions.append("Work with security team to properly classify application security zone")

        # Dependencies
        if len(self.dependencies) > 20:
            actions.append(f"Review {len(self.dependencies)} dependencies - validate all are necessary and secure")

        external_deps = [d for d in self.dependencies if d.get('type') == 'downstream_app']
        if len(external_deps) > 5:
            actions.append(f"Security review of {len(external_deps)} external service integrations")

        # Default actions if none specific
        if not actions:
            actions.append("Implement network segmentation controls between application tiers")
            actions.append("Enable TLS encryption for all service-to-service communications")
            actions.append("Configure comprehensive logging for security monitoring")

        return actions

    def _get_short_term_actions(self) -> List[str]:
        """Get short-term actions"""
        actions = [
            "Document all application dependencies and communication patterns",
            "Implement service-to-service authentication (mTLS or API keys)",
            "Configure network monitoring and alerting for your application",
            "Review and update firewall rules based on actual traffic patterns",
            "Implement rate limiting and throttling for API endpoints"
        ]

        return actions

    def _get_long_term_actions(self) -> List[str]:
        """Get long-term actions"""
        actions = [
            "Implement automated security scanning in CI/CD pipeline",
            "Deploy runtime application self-protection (RASP)",
            "Establish disaster recovery and business continuity plans",
            "Conduct regular penetration testing and security assessments",
            "Implement security metrics and KPI tracking"
        ]

        return actions

    def _guess_port(self, dep_type: str) -> str:
        """Guess port based on dependency type"""
        port_map = {
            'database': 'TCP/5432',
            'cache': 'TCP/6379',
            'queue': 'TCP/9092',
            'downstream_app': 'TCP/443',
            'service': 'TCP/8080',
            'api': 'TCP/443'
        }
        return port_map.get(dep_type, 'TCP/443')


def generate_app_specific_threat_surface_document(
    app_name: str,
    app_data: Dict,
    output_path: str
):
    """Generate app-specific threat surface document

    Args:
        app_name: Application name
        app_data: Application topology data
        output_path: Output path for Word document

    Returns:
        Path to generated document
    """
    doc_gen = AppSpecificThreatSurfaceDocument(app_name, app_data)
    doc_gen.generate_document(output_path)

    return output_path
